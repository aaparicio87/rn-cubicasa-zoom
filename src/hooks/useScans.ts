import { useState, useEffect, useCallback, useRef } from 'react';
import { storage, STORAGE_KEYS } from '../storage/mmkv';
import { ScanMetadata, PropertyType } from '../types/scan';
import {
  copyScanToDocuments,
  getFileSize,
  deleteScanFile,
  fileExists,
} from '../utils/fileSystem';
import { Alert, Platform } from 'react-native';
import NativeCubiCasa from '../../specs/NativeCubiCasa';
import BottomSheet from '@gorhom/bottom-sheet';
import { DEFAULT_PROPERTY_TYPE } from '../utils/propertyTypes';

interface IScansState {
  propertyTypes: string[];
  selectedType: string;
  isBottomSheetVisible: boolean;
  scans: ScanMetadata[];
  loading: boolean;
}

const initialState: IScansState = {
  propertyTypes: [],
  selectedType: DEFAULT_PROPERTY_TYPE,
  isBottomSheetVisible: false,
  scans: [],
  loading: true,
};

const isAndroid = Platform.OS === 'android';

export function useScans() {
  const [scansState, setScansState] = useState<IScansState>(initialState);
  const bottomSheetRef = useRef<BottomSheet>(null);

    /**
   * Load all scans saved in MMKV
   */

  const loadPropertyTypes = useCallback(async() => {
    try {
      // Get property types from SDK
      const types = NativeCubiCasa.getPropertyTypes();
      console.log('üè† Property types loaded:', types);

      // Load last saved selection
      const lastType = storage.getString(STORAGE_KEYS.LAST_PROPERTY_TYPE);
      if (lastType && types.includes(lastType)) {
        setScansState(prevState => ({
          ...prevState,
          propertyTypes: types,
          selectedType: lastType,
        }));
        console.log('‚úÖ Last type used:', lastType);
      } else {
        setScansState(prevState => ({
          ...prevState,
          propertyTypes: types,
        }));
      }
    } catch (error) {
      console.error('‚ùå Error loading property types:', error);
      setScansState(prevState => ({
        ...prevState,
        propertyTypes: [DEFAULT_PROPERTY_TYPE],
        selectedType: DEFAULT_PROPERTY_TYPE,
      }));
    }
  }, []);

  const loadScans = useCallback(() => {
    try {
      const scansJson = storage.getString(STORAGE_KEYS.SCANS);
      if (scansJson) {
        const parsedScans: ScanMetadata[] = JSON.parse(scansJson);
        // Sort by timestamp descending (most recent first)
        parsedScans.sort((a, b) => b.timestamp - a.timestamp);
        setScansState(prevState => ({
          ...prevState,
          scans: parsedScans,
          loading: false,
        }));
        console.log(`‚úÖ ${parsedScans.length} scans loaded`);
      } else {
        setScansState(prevState => ({
          ...prevState,
          scans: [],
          loading: false,
        }));
        console.log('‚ÑπÔ∏è No scans saved');
      }
    } catch (error) {
      console.error('‚ùå Error loading scans:', error);
      setScansState(prevState => ({
          ...prevState,
          scans: [],
          loading: false,
      }));
    }
  }, []);

  // Load scans when component mounts
  useEffect(() => {
    const inittialLoad = async () => {
      try {
        // Load property types and last selection on mount
        await loadPropertyTypes();
      } catch (error) {
        console.error('‚ùå Error initializing scans:', error);
      }
    };
    loadScans();
    inittialLoad(); 
  }, [loadScans, loadPropertyTypes]);

  /**
   * Save a new scan
   * @param sourcePath - Path of the original ZIP generated by the SDK
   * @param propertyType - Property type
   */
  const saveScan = useCallback(
    async (sourcePath: string, propertyType: PropertyType) => {
      try {
        const timestamp = Date.now();
        const id = timestamp.toString();

        // Copy file to Documents/scans
        const destPath = await copyScanToDocuments(sourcePath, timestamp);

        // Get file size
        const fileSize = await getFileSize(destPath);

        // Create metadata
        const newScan: ScanMetadata = {
          id,
          fileName: `tela_scan_${timestamp}.zip`,
          filePath: destPath,
          timestamp,
          propertyType,
          fileSize,
          createdAt: new Date(timestamp).toISOString(),
        };

        // Add to the list
        const updatedScans = [newScan, ...scansState.scans];

        // Save to MMKV
        storage.set(STORAGE_KEYS.SCANS, JSON.stringify(updatedScans));

        // Update state
        setScansState(prevState => ({
          ...prevState,
          scans: updatedScans,
        }));

        return newScan;
      } catch (error) {
        console.error('‚ùå Error saving scan:', error);
        throw error;
      }
    },
    [scansState.scans]
  );

  /**
   * Delete a scan
   * @param scanId - ID of the scan to delete
   */
  const deleteScan = useCallback(
    async (scanId: string) => {
      try {
        const scanToDelete = [...scansState.scans].find(s => s.id === scanId);
        if (!scanToDelete) {
          throw new Error('Scan not found');
        }

        // Delete physical file
        await deleteScanFile(scanToDelete.filePath);

        // Remove from list
        const updatedScans = [...scansState.scans].filter(s => s.id !== scanId);

        // Save to MMKV
        storage.set(STORAGE_KEYS.SCANS, JSON.stringify(updatedScans));

        // Update state
        setScansState(prevState => ({
          ...prevState,
          scans: updatedScans,
        }));

        console.log('‚úÖ Scan deleted:', scanToDelete.fileName);
      } catch (error) {
        console.error('‚ùå Error deleting scan:', error);
        throw error;
      }
    },
    [scansState.scans]
  );

  /**
   * Refresh the list of scans
   */
  const refresh = useCallback(() => {
    setScansState(prevState => ({
      ...prevState,
      loading: !prevState.loading,
    }));
    loadScans();
  }, [loadScans]);


  const requestLocationPermission = async () => {
    try {
      const result = await NativeCubiCasa.requestLocationPermission();
      console.log('üìç Location permission:', result);
    } catch (permError: any) {
      console.warn('‚ö†Ô∏è Location error:', permError);
      // Continue anyway (azimuth is optional)
    }
  }

  const verifyAndroidARCore =  () => {
    const isCompatible = NativeCubiCasa.isARCoreAvailable();
      
    if (!isCompatible) {
      Alert.alert(
        'Device Not Compatible',
        'This device does not support AR scanning. AR features require Google Play Services for AR to be installed and up to date.\n\nPlease install or update it from the Play Store.',
        [
          {
            text: 'OK',
            style: 'cancel',
          },
        ]
      );
    }
    return isCompatible;
  }

  const openBottomSheet = () => {
    if(isAndroid){
      const isAndroidCompatible = verifyAndroidARCore();
      if(!isAndroidCompatible){
        return;
      }
    }
    setScansState(prevState => ({
      ...prevState,
      isBottomSheetVisible: !prevState.isBottomSheetVisible,
    }));
    bottomSheetRef.current?.expand();
  };

  const handleCloseBottomSheet = () => {
    bottomSheetRef.current?.close();
    setScansState(prevState => ({
      ...prevState,
      isBottomSheetVisible: false,
    }));
  };

  const handleSelectType = (type: string) => {
    setScansState(prevState => ({
      ...prevState,
      selectedType: type,
    }));
  };

  /**
   * Starts a new scan
   */
  const handleStartScan = async () => {
    try {
      handleCloseBottomSheet();
      console.log('üì∏ Starting scan...');
      await requestLocationPermission();

      const fileName = `scan_${Date.now()}`;
      const zipPath = await NativeCubiCasa.startScan(
        fileName,
        scansState.selectedType,
      );

      console.log('‚úÖ Scan completed:', zipPath);

      // Save the scan
      await saveScan(zipPath, scansState.selectedType as any);

      Alert.alert('Success!', 'The scan was saved successfully');
    } catch (error: any) {
      console.error('‚ùå Error in scan:', error);

      if (error.code === 'UNSUPPORTED') {
        Alert.alert(
          'Incompatible device',
          'This device does not support scanning. You need an iPhone with iOS 17+ and ARKit.',
        );
      } else if (error.code === 'CANCELLED') {
        console.log('‚ÑπÔ∏è Scan cancelled by the user');
      } else {
        Alert.alert('Error', `Could not complete the scan: ${error.message}`);
      }
    }
  };

  /**
   * Share zip file
   */
  const handleShare = async (scan: ScanMetadata) => {
    try {
      console.log('üì§ Sharing:', scan.fileName);

      // Verify that the file exists
      const exists = await fileExists(scan.filePath);

      if (!exists) {
        console.warn('‚ö†Ô∏è File does not exist:', scan.filePath);

        Alert.alert(
          'File not found',
          'The file no longer exists. Do you want to remove this scan from the list?',
          [
            {
              text: 'Cancel',
              style: 'cancel',
            },
            {
              text: 'Remove',
              style: 'destructive',
              onPress: async () => {
                try {
                  // Only remove metadata (file no longer exists)
                  const updatedScans = [...scansState.scans].filter(s => s.id !== scan.id);
                  storage.set(STORAGE_KEYS.SCANS, JSON.stringify(updatedScans));
                  refresh();
                  Alert.alert('Removed', 'The scan was removed from the list');
                } catch (error) {
                  console.error('‚ùå Error cleaning metadata:', error);
                }
              },
            },
          ],
        );
        return;
      }

      // If it exists, share
      await NativeCubiCasa.shareFile(scan.filePath);
      console.log('‚úÖ Share menu presented');
    } catch (error: any) {
      console.error('‚ùå Error sharing:', error);
      Alert.alert('Error', 'Could not share the file');
    }
  };

  /**
   * Deletes zip file
   */
  const handleDelete = (scan: ScanMetadata) => {
    Alert.alert(
      'Delete scan',
      `Are you sure you want to delete "${scan.fileName}"?`,
      [
        {
          text: 'Cancel',
          style: 'cancel',
        },
        {
          text: 'Delete',
          style: 'destructive',
          onPress: async () => {
            try {
              await deleteScan(scan.id);
              Alert.alert('Deleted', 'The scan was deleted successfully');
            } catch (error) {
              console.error('‚ùå Error deleting:', error);
              Alert.alert('Error', 'Could not delete the file');
            }
          },
        },
      ],
    );
  };

  return {
    saveScan,
    deleteScan,
    refresh,
    openBottomSheet,
    handleSelectType,
    handleStartScan,
    handleDelete,
    handleShare,
    scansState,
    bottomSheetRef,
    handleCloseBottomSheet,
  };
}